/*
 * Copyright Â© 2024 fluffydaddy
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.fluffydaddy.jutils.reflect;

import java.lang.reflect.*;
import java.util.Objects;
import java.util.Stack;

public class ClassUtils {
    public static <V> void setField(Class<?> clazz, Object instance, String name, V value) throws NoSuchFieldException {
        try {
            Field field = clazz.getDeclaredField(name);
            field.setAccessible(true);
            field.set(instance, value);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    public static <V> void setField(Class<?> clazz, String name, V value) throws NoSuchFieldException {
        try {
            Field field = clazz.getDeclaredField(name);
            field.setAccessible(true);
            field.set(null, value);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    public static <V> void setField(String name, V value, Object instance) throws NoSuchFieldException {
        setField(instance == null ? null : instance.getClass(), instance, name, value);
    }


    public static <V> V getField(String name, Object instance) throws NoSuchFieldException {
        if (instance == null || (name == null || name.trim().isEmpty())) return null;

        Class<?> clazz = instance.getClass();

        try {
            Field field = clazz.getDeclaredField(name);
            field.setAccessible(true);
            return (V) field.get(instance);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static <V> V getField(String name, Class<?> clazz) throws NoSuchFieldException {
        try {
            Field field = clazz.getDeclaredField(name);
            field.setAccessible(true);
            return (V) field.get(null);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static Field getField(Object instance, String name) {
        return instance == null ? null : getField(instance.getClass(), name);
    }

    public static Field getField(Class<?> clazz, String name) {
        try {
            Field field = clazz.getDeclaredField(name);
            field.setAccessible(true);
            return field;
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
            return null;
        }
    }


    public static <V> V getStaticField(Class<?> clazz, Class<V> type, String name) {
        Field field = getField(clazz, name);

        if (field == null) return null;

        if (!Modifier.isStatic(field.getModifiers()))
            return null;

        try {
            if (field.getType() != type)
                throw new IllegalStateException("Field founded type " + field.getType() + ", a required type " + type);

            return (V) field.get(null);
        } catch (IllegalAccessException ignored) {
        }

        return null;
    }


    public static <T> void swap(T arg1, T arg2) {
        if (arg1 == null && arg2 == null)
            return;

        T valC;
        T chgC;

        if (arg1 == null) {
            chgC = arg2;
            valC = null;
        } else {
            chgC = arg1;
            valC = arg2;
        }

        if (arg1 instanceof Number || arg2 instanceof Number) {
            try {
                swap(chgC, valC, "value");
            } catch (IllegalAccessException e) {
                System.err.println(e);
            }
        } else {
            Field[] fields = getFields(chgC);

            for (Field field : fields) {
                try {
                    field.setAccessible(true);
                    field.set(chgC, field.get(valC));
                    field.setAccessible(false);
                } catch (IllegalAccessException ignored) {
                }
            }
        }
    }

    private static <T> void swap(T arg1, T arg2, String valName) throws IllegalArgumentException, IllegalAccessException {
        if ((arg1 == null && arg2 == null) || valName == null)
            return;

        T valC;
        T chgC;

        if (arg1 == null) {
            chgC = arg2;
            valC = null;
        } else {
            chgC = arg1;
            valC = arg2;
        }


        Field[] fields = getFields(chgC);

        for (Field field : fields) {
            String fldName = field.getName();

            if (fldName.equals(valName)) {
                field.setAccessible(true);
                field.set(chgC, valC);
                field.setAccessible(false);

                break;
            }
        }
    }

    private static Field[] getFields(Object o) {
        if (o == null)
            return new Field[0];

        return o.getClass().getDeclaredFields();
    }


    public static Method getMethod(Object instance, String name, Object... params) {
        Objects.requireNonNull(instance);
        Objects.requireNonNull(name);

        return getMethod(instance.getClass(), name, params);
    }


    public static Method getMethod(Class<?> clazz, String name, Object... params) {
        Objects.requireNonNull(clazz);
        Objects.requireNonNull(name);

        Method method = null;

        if (params == null || params.length == 0) {
            try {
                method = clazz.getMethod(name);
                method.setAccessible(true);
            } catch (NoSuchMethodException ignored) {
                try {
                    method = clazz.getDeclaredMethod(name);
                    method.setAccessible(true);
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                }
            }
        } else {
            Class<?>[] classTypes = new Class<?>[params.length];

            for (int i = 0; i < params.length; i++) {
                Object param = params[i];

                Class<?> paramType = param.getClass();

                classTypes[i] = paramType;
            }

            try {
                method = clazz.getMethod(name, classTypes);
                method.setAccessible(true);
            } catch (NoSuchMethodException ignored) {
                try {
                    method = clazz.getDeclaredMethod(name, classTypes);
                    method.setAccessible(true);
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                }
            }
        }

        return method;
    }

    public static <R> R invokeMethod(Class<?> cls, String name, Class<?>[] paramTypes, Object[] args) throws InvocationTargetException, NoSuchMethodException {
        Objects.requireNonNull(cls);
        Objects.requireNonNull(name);

        Method method = findMethod(cls, name, paramTypes);

        method.setAccessible(true);

        try {
            return (R) method.invoke(null, args);
        } catch (IllegalAccessException ignored) {
        }

        return null;
    }

    public static <R> R invokeMethod(Object instance, String name, Class<?>[] paramTypes, Object... args) throws InvocationTargetException {
        Objects.requireNonNull(instance);
        Objects.requireNonNull(name);

        try {
            Class<?> clz = instance.getClass();
            Method method = findMethod(clz, name, paramTypes);

            method.setAccessible(true);

            try {
                return (R) method.invoke(instance, args);
            } catch (IllegalAccessException ignored) {
            }
        } catch (NoSuchMethodException ignored) {
        }

        return null;
    }

    private static Method findMethod(Class<?> clazz, String name, Class<?>[] paramTypes) throws NoSuchMethodException, SecurityException {
        Objects.requireNonNull(clazz);

        Method method = findMethod(clazz.getMethods(), name, paramTypes);

        if (method == null) {
            method = findMethod(clazz.getDeclaredMethods(), name, paramTypes);
        }

        if (method == null) {
            method = clazz.getMethod(name, paramTypes);
        }

        return method;
    }

    private static Method findMethod(Method[] methods, String name, Class<?>[] paramTypes) {
        Method method = null;

        for (int i = 0; i < methods.length; i++) {
            method = methods[i];
            Class[] params = method.getParameterTypes();
            boolean isEqual = false;

            if (params.length != paramTypes.length) {
                method = null;
                continue;
            }

            for (int j = 0; i < params.length; j++) {
                Class oparam = params[i];
                Class mparam = paramTypes[i];

                if (oparam.isAssignableFrom(mparam)) {
                    isEqual = true;
                    break;
                }
            }

            if (isEqual) break;
        }

        return method;
    }

    public static <R> R invokeMethod(Object instance, Class<?> cls, String name, Object... args) throws InvocationTargetException {
        Objects.requireNonNull(instance);
        Objects.requireNonNull(cls);
        Objects.requireNonNull(name);

        Method method = getMethod(cls, name, args);

        try {
            return (R) method.invoke(instance, args);
        } catch (IllegalAccessException ignored) {
        }

        return null;
    }

    public static <V> V instance(Class<?> clazz) throws InstantiationException {
        return instance(clazz, null);
    }

    public static <V> V instance(Class<?> clazz, Object[] paramValues) throws InstantiationException {
        if (paramValues == null) return instance(clazz, null, null);
        Class<?>[] paramTypes = new Class<?>[paramValues.length];
        for (int i = 0; i < paramValues.length; i++) paramTypes[i] = paramValues[i].getClass();
        return instance(clazz, paramTypes, paramValues);
    }

    public static <V> V instance(Class<?> clazz, Class<?>[] paramTypes, Object[] paramValues) throws InstantiationException {
        try {
            return (V) clazz.getConstructor(paramTypes).newInstance(paramValues);
        } catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            e.printStackTrace();
            return null;
        }
    }


    public static <T> Class<? extends T> getClass(T obj) {
        if (obj == null) return null;

        if (obj instanceof Class<?>)
            return ((Class<? extends T>) obj);
        else
            return (Class<? extends T>) obj.getClass();
    }

    public static Class<?> getGenericType(Object obj) {
        return getGenericType(0, obj);
    }

    public static Class<?> getGenericType(int index, Object obj) {
        return getGenericType(index, getClass(obj));
    }

    public static Class<?> getGenericType(Class<?> clazz) {
        return getGenericType(0, clazz);
    }

    public static Class<?> getGenericType(int index, Class<?> clazz) {
        return (Class<?>) ((ParameterizedType) clazz
                .getGenericSuperclass()).getActualTypeArguments()[index];
    }


    public static Class<?> getGenericClass(Object obj) {
        return getGenericClass(0, obj);
    }

    public static Class<?> getGenericClass(int index, Object actualObj) {
        Class<?> clazz;
        if (actualObj instanceof Class)
            clazz = (Class<?>) actualObj;
        else
            clazz = actualObj.getClass();

        return getGenericParameterClass(clazz, clazz, index);
    }

    public static Class<?> getGenericClass(Class<?> clazz) {
        return getGenericType(0, clazz);
    }

    public static Class<?> getGenericClass(int index, Class<?> clazz) {
        return (Class<?>) ((ParameterizedType) clazz
                .getGenericSuperclass()).getActualTypeArguments()[index];
    }


    /*
     * Method From Habr
     * https://habr.com/ru/post/66593/
     */

    /**
     * ÐÐ»Ñ Ð½ÐµÐºÐ¾ÑÐ¾ÑÐ¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ° Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÐµÑ ÐºÐ°ÐºÐ¸Ð¼ ÐºÐ»Ð°ÑÑÐ¾Ð¼ Ð±ÑÐ» Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·Ð¾Ð²Ð°Ð½ Ð¾Ð´Ð¸Ð½ Ð¸Ð· ÐµÐ³Ð¾ Ð¿ÑÐµÐ´ÐºÐ¾Ð² Ñ generic-Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°Ð¼Ð¸.
     *
     * @param actualClass    Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ÑÐ¹ ÐºÐ»Ð°ÑÑ
     * @param genericClass   ÐºÐ»Ð°ÑÑ, Ð´Ð»Ñ ÐºÐ¾ÑÐ¾ÑÐ¾Ð³Ð¾ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÐµÑÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°
     * @param parameterIndex Ð½Ð¾Ð¼ÐµÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°
     * @return ÐºÐ»Ð°ÑÑ, ÑÐ²Ð»ÑÑÑÐ¸Ð¹ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð¼ Ñ Ð¸Ð½Ð´ÐµÐºÑÐ¾Ð¼ parameterIndex Ð² genericClass
     */

    public static <T> Class<? super T> getGenericParameterClass(final Class<? super T> actualClass, final Class<?> genericClass, final int parameterIndex) {
        // ÐÑÐµÐºÑÐ°ÑÐ°ÐµÐ¼ ÑÐ°Ð±Ð¾ÑÑ ÐµÑÐ»Ð¸ genericClass Ð½Ðµ ÑÐ²Ð»ÑÐµÑÑÑ Ð¿ÑÐµÐ´ÐºÐ¾Ð¼ actualClass.
        if (actualClass.isInterface()) {
            if (!genericClass.isAssignableFrom(actualClass)) {
                throw new IllegalArgumentException("Interface " + genericClass.getName() + " is not a implement of "
                        + actualClass.getName() + ".");
            }
        } else {
            if ((!genericClass.isAssignableFrom(actualClass.getSuperclass()))) {
                throw new IllegalArgumentException("Class " + genericClass.getName() + " is not a superclass of "
                        + actualClass.getName() + ".");
            }
        }

        // ÐÐ°Ð¼ Ð½ÑÐ¶Ð½Ð¾ Ð½Ð°Ð¹ÑÐ¸ ÐºÐ»Ð°ÑÑ, Ð´Ð»Ñ ÐºÐ¾ÑÐ¾ÑÐ¾Ð³Ð¾ Ð½ÐµÐ¿Ð¾ÑÑÐµÐ´ÑÑÐ²ÐµÐ½Ð½ÑÐ¼ ÑÐ¾Ð´Ð¸ÑÐµÐ»ÐµÐ¼ Ð±ÑÐ´ÐµÑ genericClass.
        // ÐÑ Ð±ÑÐ´ÐµÐ¼ Ð¿Ð¾Ð´Ð½Ð¸Ð¼Ð°ÑÑÑÑ Ð²Ð²ÐµÑÑ Ð¿Ð¾ Ð¸ÐµÑÐ°ÑÑÐ¸Ð¸, Ð¿Ð¾ÐºÐ° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ¼ Ð¸Ð½ÑÐµÑÐµÑÑÑÑÐ¸Ð¹ Ð½Ð°Ñ ÐºÐ»Ð°ÑÑ.
        // Ð Ð¿ÑÐ¾ÑÐµÑÑÐµ Ð¿Ð¾Ð´Ð½ÑÑÐ¸Ñ Ð¼Ñ Ð±ÑÐ´ÐµÐ¼ ÑÐ¾ÑÑÐ°Ð½ÑÑÑ Ð² genericClasses Ð²ÑÐµ ÐºÐ»Ð°ÑÑÑ - Ð¾Ð½Ð¸ Ð½Ð°Ð¼ Ð¿Ð¾Ð½Ð°Ð´Ð¾Ð±ÑÑÑÑ Ð¿ÑÐ¸ ÑÐ¿ÑÑÐºÐµ Ð²Ð½Ð¸Ð·.

        // ÐÑÐ¾ÐµÐ¹Ð´ÐµÐ½Ð½ÑÐµ ÐºÐ»Ð°ÑÑÑ - Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÑÑ Ð´Ð»Ñ ÑÐ¿ÑÑÐºÐ° Ð²Ð½Ð¸Ð·.
        Stack<ParameterizedType> genericClasses = new Stack<>();

        // clazz - ÑÐµÐºÑÑÐ¸Ð¹ ÑÐ°ÑÑÐ¼Ð°ÑÑÐ¸Ð²Ð°ÐµÐ¼ÑÐ¹ ÐºÐ»Ð°ÑÑ
        Class<? super T> clazz = actualClass;

        while (true) {
            Type genericSuperclass = clazz.getGenericSuperclass();
            boolean isParameterizedType = genericSuperclass instanceof ParameterizedType;
            if (isParameterizedType) {
                // ÐÑÐ»Ð¸ Ð¿ÑÐµÐ´Ð¾Ðº - Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·Ð¾Ð²Ð°Ð½Ð½ÑÐ¹ ÐºÐ»Ð°ÑÑ, ÑÐ¾ Ð·Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÐ¼ ÐµÐ³Ð¾ - Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð¾Ð½ Ð¿ÑÐ¸Ð³Ð¾Ð´Ð¸ÑÑÑ Ð¿ÑÐ¸ ÑÐ¿ÑÑÐºÐµ Ð²Ð½Ð¸Ð·.
                genericClasses.push((ParameterizedType) genericSuperclass);
            } else {
                // Ð Ð¸ÐµÑÐ°ÑÑÐ¸Ð¸ Ð²ÑÑÑÐµÑÐ¸Ð»ÑÑ Ð½ÐµÐ¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·Ð¾Ð²Ð°Ð½Ð½ÑÐ¹ ÐºÐ»Ð°ÑÑ. ÐÑÐµ ÑÐ°Ð½ÐµÐµ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·Ð¾Ð²Ð°Ð½Ð½ÑÐµ ÐºÐ»Ð°ÑÑÑ Ð±ÑÐ´ÑÑ Ð±ÐµÑÐ¿Ð¾Ð»ÐµÐ·Ð½Ñ.
                genericClasses.clear();
            }
            // ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼, Ð´Ð¾ÑÐ»Ð¸ Ð¼Ñ Ð´Ð¾ Ð½ÑÐ¶Ð½Ð¾Ð³Ð¾ Ð¿ÑÐµÐ´ÐºÐ° Ð¸Ð»Ð¸ Ð½ÐµÑ.
            Type rawType = isParameterizedType ? ((ParameterizedType) genericSuperclass).getRawType() : genericSuperclass;
            if (!rawType.equals(genericClass)) {
                // genericClass Ð½Ðµ ÑÐ²Ð»ÑÐµÑÑÑ Ð½ÐµÐ¿Ð¾ÑÑÐµÐ´ÑÑÐ²ÐµÐ½Ð½ÑÐ¼ ÑÐ¾Ð´Ð¸ÑÐµÐ»ÐµÐ¼ Ð´Ð»Ñ ÑÐµÐºÑÑÐµÐ³Ð¾ ÐºÐ»Ð°ÑÑÐ°.
                // ÐÐ¾Ð´Ð½Ð¸Ð¼Ð°ÐµÐ¼ÑÑ Ð¿Ð¾ Ð¸ÐµÑÐ°ÑÑÐ¸Ð¸ Ð´Ð°Ð»ÑÑÐµ.
                clazz = clazz.getSuperclass();
            } else {
                // ÐÑ Ð¿Ð¾Ð´Ð½ÑÐ»Ð¸ÑÑ Ð´Ð¾ Ð½ÑÐ¶Ð½Ð¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ°. ÐÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ÑÑ.
                break;
            }
        }

        // ÐÑÐ¶Ð½ÑÐ¹ ÐºÐ»Ð°ÑÑ Ð½Ð°Ð¹Ð´ÐµÐ½. Ð¢ÐµÐ¿ÐµÑÑ Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐ·Ð½Ð°ÑÑ, ÐºÐ°ÐºÐ¸Ð¼Ð¸ ÑÐ¸Ð¿Ð°Ð¼Ð¸ Ð¾Ð½ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·Ð¾Ð²Ð°Ð½.
        Type result = genericClasses.pop().getActualTypeArguments()[parameterIndex];

        while (result instanceof TypeVariable && !genericClasses.empty()) {
            // ÐÐ¾ÑÐ¾Ð¶Ðµ Ð½Ð°Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ Ð·Ð°Ð´Ð°Ð½ Ð³Ð´Ðµ-ÑÐ¾ Ð½Ð¸Ð¶Ðµ Ð¿Ð¾ Ð¸ÐµÑÐ°ÑÑÐ¸Ð¸, ÑÐ¿ÑÑÐºÐ°ÐµÐ¼ÑÑ Ð²Ð½Ð¸Ð·.

            // ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¸Ð½Ð´ÐµÐºÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ° Ð² ÑÐ¾Ð¼ ÐºÐ»Ð°ÑÑÐµ, Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ Ð¾Ð½ Ð·Ð°Ð´Ð°Ð½.
            int actualArgumentIndex = getParameterTypeDeclarationIndex((TypeVariable<?>) result);
            // ÐÐµÑÐµÐ¼ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐ¸Ð¹ ÐºÐ»Ð°ÑÑ, ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÐ¸Ð¹ Ð¼ÐµÑÐ°Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð½Ð°ÑÐµÐ¼ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐµ.
            ParameterizedType type = genericClasses.pop();
            // ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¸ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°.
            result = type.getActualTypeArguments()[actualArgumentIndex];
        }

        if (result instanceof TypeVariable) {
            // ÐÑ ÑÐ¿ÑÑÑÐ¸Ð»Ð¸ÑÑ Ð´Ð¾ ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð½Ð¸Ð·Ð°, Ð½Ð¾ Ð´Ð°Ð¶Ðµ ÑÐ°Ð¼ Ð½ÑÐ¶Ð½ÑÐ¹ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ Ð½Ðµ Ð¸Ð¼ÐµÐµÑ ÑÐ²Ð½Ð¾Ð³Ð¾ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ.
            // Ð¡Ð»ÐµÐ´Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾ Ð¸Ð·-Ð·Ð° "Type erasure" ÑÐ·Ð½Ð°ÑÑ ÐºÐ»Ð°ÑÑ Ð´Ð»Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ° Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾.
            throw new IllegalStateException("Unable to resolve type variable " + result + "."
                    + " Try to replace instances of parametrized class with its non-parameterized subtype.");
        }

        if (result instanceof ParameterizedType) {
            // Ð¡Ð°Ð¼ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ Ð¾ÐºÐ°Ð·Ð°Ð»ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·Ð¾Ð²Ð°Ð½Ð½ÑÐ¼.
            // ÐÑÐ±ÑÐ¾ÑÐ¸Ð¼ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ ÐµÐ³Ð¾ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°Ñ, Ð¾Ð½Ð° Ð½Ð°Ð¼ Ð½Ðµ Ð½ÑÐ¶Ð½Ð°.
            result = ((ParameterizedType) result).getRawType();
        }

        if (result == null) {
            // Should never happen. :)
            throw new IllegalStateException("Unable to determine actual parameter type for "
                    + actualClass.getName() + ".");
        }

        if (!(result instanceof Class)) {
            // ÐÐ¾ÑÐ¾Ð¶Ðµ, ÑÑÐ¾ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ - Ð¼Ð°ÑÑÐ¸Ð² Ð¸Ð»Ð¸ ÑÑÐ¾-ÑÐ¾ ÐµÑÐµ, ÑÑÐ¾ Ð½Ðµ ÑÐ²Ð»ÑÐµÑÑÑ ÐºÐ»Ð°ÑÑÐ¾Ð¼.
            throw new IllegalStateException("Actual parameter type for " + actualClass.getName() + " is not a Class.");
        }

        return (Class<? super T>) result;
    }

    public static <T> Class<? super T> getGenericParameterClass(Class<? super T> actualClass, int parameterIndex) {
        return getGenericParameterClass(actualClass, actualClass, parameterIndex);
    }

    public static int getParameterTypeDeclarationIndex(final TypeVariable<?> typeVariable) {
        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();

        // ÐÑÐµÐ¼ Ð½Ð°Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ ÑÑÐµÐ´Ð¸ Ð²ÑÐµÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÐ¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ°, Ð³Ð´Ðµ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½ Ð½ÑÐ¶Ð½ÑÐ¹ Ð½Ð°Ð¼ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ.
        TypeVariable<?>[] typeVariables = genericDeclaration.getTypeParameters();
        Integer actualArgumentIndex = null;
        for (int i = 0; i < typeVariables.length; i++) {
            if (typeVariables[i].equals(typeVariable)) {
                actualArgumentIndex = i;
                break;
            }
        }
        if (actualArgumentIndex != null) {
            return actualArgumentIndex;
        } else {
            throw new IllegalStateException("Argument " + typeVariable.toString() + " is not found in "
                    + genericDeclaration.toString() + ".");
        }
    }
}